// Generated by CoffeeScript 1.4.0
(function() {
  var EventEmitter, FileTask, FileTaskSpec, Makelet, Task, TaskSpec, TopLevelTask, async, fileNewerThan, fs, loglet, patsubst, patternFileSubst, patternFiles, patternRootDir, patternSplitAtRootDir, patternToRegex, patternToReplace, utilities, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  loglet = require('loglet');

  fs = require('fs');

  utilities = require('utilities');

  _ = require('underscore');

  async = require('async');

  EventEmitter = require('events').EventEmitter;

  fileNewerThan = function(targetPath, dependPaths, cb) {
    var helper;
    helper = function(target, depends) {
      var res;
      res = _.find(depends, function(dep) {
        return target.mtime < dep.mtime;
      });
      if (res) {
        return true;
      } else {
        return false;
      }
    };
    return fs.stat(targetPath, function(err, target) {
      if (err) {
        loglet.debug('fileNewerThan:no_target', targetPath, err);
        return cb(null, true);
      } else {
        return async.map(dependPaths, fs.stat, function(err, depends) {
          if (err) {
            loglet.debug('fileNewerThan:no_depend_file', dependPaths, err);
            return cb(null, false);
          } else {
            return cb(null, helper(target, depends));
          }
        });
      }
    });
  };

  patternRootDir = function(pat) {
    var rootDir, _ref;
    _ref = patternSplitAtRootDir(pat), rootDir = _ref[0], pat = _ref[1];
    return rootDir;
  };

  patternSplitAtRootDir = function(pat) {
    var helper, i, res, seg, segments, _i, _len;
    segments = pat.split('/');
    res = [];
    helper = function(res) {
      var rest;
      rest = segments.slice(res.length).join('/');
      if (res.length === 0) {
        return ['.', rest];
      } else {
        return [res.join('/'), rest];
      }
    };
    for (i = _i = 0, _len = segments.length; _i < _len; i = ++_i) {
      seg = segments[i];
      if (seg.indexOf('%') === -1 && i < (segments.length - 1)) {
        res.push(seg);
        continue;
      } else {
        return helper(res);
      }
    }
    return helper(res);
  };

  patternToRegex = function(pat) {
    var regex;
    regex = pat.replace(/\\?!(b|B|d|D|f|n|r|s|S|t|v|W|n|0|c[A-Z]|x[0-9a-zA-Z]{2}|u[0-9a-zA-Z]{4})/g, '\\\\').replace(/\//g, '\\/').replace('.', '\\.').replace(/%/g, '([^\\\/\\\\]+?)');
    return new RegExp('^' + regex + '$');
  };

  patternToReplace = function(pat) {
    var i;
    if (typeof pat === 'function') {
      return pat;
    } else {
      i = 0;
      return pat.replace(/%/g, function() {
        i++;
        return "$" + i;
      });
    }
  };

  patternFiles = function(pat) {
    var files, regex, rootDir;
    rootDir = patternRootDir(pat);
    regex = patternToRegex(pat);
    try {
      files = utilities.file.readdirR(rootDir);
      loglet.debug('makelet.patternFiles.regex', pat, rootDir, regex, files);
      return _.filter(files, function(file) {
        var match;
        match = file.match(regex);
        return match;
      });
    } catch (e) {
      loglet.error('makelet.patternFiles.error', e);
      return [];
    }
  };

  patternFileSubst = function(sourcePat, targetPat) {
    var file, files, sourceRegex, _i, _len, _results;
    sourceRegex = patternToRegex(sourcePat);
    targetPat = patternToReplace(targetPat);
    files = patternFiles(sourcePat);
    _results = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      _results.push([file, file.replace(sourceRegex, targetPat)]);
    }
    return _results;
  };

  patsubst = function(files, sourcePat, targetPat) {
    var file, sourceRegex, _i, _len, _results;
    sourceRegex = patternToRegex(sourcePat);
    targetPat = patternToReplace(targetPat);
    _results = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      _results.push(file.replace(sourceRegex, targetPat));
    }
    return _results;
  };

  TaskSpec = (function() {

    function TaskSpec(name, depends, work) {
      this.name = name;
      this.depends = depends;
      this.work = work;
    }

    TaskSpec.prototype.make = function() {
      return new Task(this.name, this.work);
    };

    TaskSpec.prototype.dependsOn = function(name) {
      return this.depends.indexOf(name) !== -1;
    };

    return TaskSpec;

  })();

  Task = (function(_super) {

    __extends(Task, _super);

    function Task(name, work) {
      this.name = name;
      this.work = work;
      this._runCallback = __bind(this._runCallback, this);

      this.onDependDone = __bind(this.onDependDone, this);

      this.depends = {};
      this.completes = {};
      this.status = {};
    }

    Task.prototype.addDepends = function(depends) {
      var task, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = depends.length; _i < _len; _i++) {
        task = depends[_i];
        this.depends[task.name] = task;
        _results.push(task.once('done', this.onDependDone));
      }
      return _results;
    };

    Task.prototype.dependsOn = function(task) {
      return _.find(Object.keys(this.depends), function(name) {
        return task.name === name;
      });
    };

    Task.prototype.dependsKeys = function() {
      return Object.keys(this.depends);
    };

    Task.prototype.onDependDone = function(task, err) {
      if (err) {
        this.status = {
          error: err
        };
        this.reset();
        return this.emit('done', task, err);
      } else {
        if (err === false) {
          this.completes[task.name] = false;
        } else {
          this.completes[task.name] = true;
        }
        return this.tryRun();
      }
    };

    Task.prototype.reset = function() {
      var depend, key, _ref, _results;
      _ref = this.depends;
      _results = [];
      for (key in _ref) {
        depend = _ref[key];
        _results.push(depend.removeListener('done', this.onDependDone));
      }
      return _results;
    };

    Task.prototype.tryRun = function() {
      var allFinished, allStopped, depend, key, _ref;
      allFinished = true;
      allStopped = true;
      _ref = this.depends;
      for (key in _ref) {
        depend = _ref[key];
        if (this.completes.hasOwnProperty(key)) {
          if (this.completes[key] === true) {
            allStopped = false;
          }
        } else {
          allFinished = false;
          break;
        }
      }
      loglet.debug('Task.tryRun', this.name);
      return this._startRun(allFinished, allStopped);
    };

    Task.prototype._startRun = function(allFinished, allStopped) {
      if (allFinished) {
        this.reset();
        if (!allStopped) {
          return this._run();
        } else {
          this.status = {
            stopped: true
          };
          return this.emit('done', this, false);
        }
      }
    };

    Task.prototype._run = function() {
      var _this = this;
      this.emit('start', this.name);
      if (this.work instanceof Function) {
        return process.nextTick(function() {
          return _this.work.call(_this, {}, _this._runCallback);
        });
      } else {
        return this._runCallback();
      }
    };

    Task.prototype._runCallback = function(err) {
      if (err) {
        this.status = {
          error: err
        };
        return this.emit('done', this, err);
      } else if (err === false) {
        this.status = {
          stopped: true
        };
        return this.emit('done', this, false);
      } else {
        this.status = {
          completed: true
        };
        return this.emit('done', this, null);
      }
    };

    Task.prototype.trace = function(level) {
      var i, key, tab, task, _ref, _results;
      if (level == null) {
        level = 0;
      }
      tab = ((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= level ? _i < level : _i > level; i = 0 <= level ? ++_i : --_i) {
          _results.push('  ');
        }
        return _results;
      })()).join('');
      loglet.log(tab + this.name);
      _ref = this.depends;
      _results = [];
      for (key in _ref) {
        task = _ref[key];
        _results.push(task.trace(level + 1));
      }
      return _results;
    };

    Task.prototype.start = function() {
      return this._run();
    };

    return Task;

  })(EventEmitter);

  FileTask = (function(_super) {

    __extends(FileTask, _super);

    function FileTask(name, work, dependPaths) {
      this.dependPaths = dependPaths;
      FileTask.__super__.constructor.call(this, name, work);
    }

    FileTask.prototype.addDepends = function(depends) {
      var dependPaths, dependTasks, key, path, task, _i, _len, _ref, _ref1, _results;
      dependPaths = [];
      dependTasks = [];
      _ref = this.dependPaths;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        path = _ref[_i];
        task = _.find(depends, function(task) {
          return task.name === path;
        });
        if ((!task) || (task instanceof FileTask)) {
          dependPaths.push(path);
        }
      }
      this.dependPaths = dependPaths;
      FileTask.__super__.addDepends.call(this, depends);
      this.nonFileDepends = [];
      _ref1 = this.depends;
      _results = [];
      for (key in _ref1) {
        task = _ref1[key];
        if (!(task instanceof FileTask)) {
          _results.push(this.nonFileDepends.push(task));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    FileTask.prototype._startRun = function(allFinished, allStopped) {
      loglet.debug('FileTask._startRun', this.name, allFinished, allStopped, this.depends);
      if (allFinished) {
        this.reset();
        return this._run();
      }
    };

    FileTask.prototype._run = function() {
      var _this = this;
      loglet.debug('FileTask._run', this.name);
      if (this.nonFileDepends.length > 0) {
        return FileTask.__super__._run.call(this);
      } else {
        return process.nextTick(function() {
          return fileNewerThan(_this.name, _this.dependPaths, function(err, res) {
            _this.emit('start', _this.name);
            if (err) {
              return _this._runCallback(err);
            } else if (res) {
              if (!(_this.work instanceof Function)) {
                loglet.croak({
                  error: 'missing_FileTask_work',
                  task: _this
                });
              }
              return _this.work({
                source: _this.dependPaths[0],
                sources: _this.dependPaths,
                target: _this.name
              }, _this._runCallback);
            } else {
              return _this._runCallback(false);
            }
          });
        });
      }
    };

    return FileTask;

  })(Task);

  FileTaskSpec = (function(_super) {

    __extends(FileTaskSpec, _super);

    function FileTaskSpec() {
      return FileTaskSpec.__super__.constructor.apply(this, arguments);
    }

    FileTaskSpec.prototype.make = function() {
      return new FileTask(this.name, this.work, this.depends);
    };

    return FileTaskSpec;

  })(TaskSpec);

  TopLevelTask = (function(_super) {

    __extends(TopLevelTask, _super);

    function TopLevelTask(organizer, taskNames, cb) {
      var key, task, tasks, _ref;
      this.cb = cb;
      this.onDependDone = __bind(this.onDependDone, this);

      tasks = organizer.makeTasks2(taskNames);
      loglet.debug('TopLevelTask.ctor', tasks);
      this.root = this.findRoot(tasks);
      this.depends = this.findBottom(tasks);
      loglet.debug('TopLevelTask.ctor', taskNames, this.root, this.depends);
      this.completes = {};
      _ref = this.depends;
      for (key in _ref) {
        task = _ref[key];
        task.once('done', this.onDependDone);
      }
    }

    TopLevelTask.prototype.reset = function() {
      var key, task, _ref, _results;
      _ref = this.bottom;
      _results = [];
      for (key in _ref) {
        task = _ref[key];
        _results.push(task.removeListener('done', this.onDependDone));
      }
      return _results;
    };

    TopLevelTask.prototype.onDependDone = function(task, err) {
      if (err) {
        this.reset();
        return this.cb.call(this, err);
      } else {
        if (err === false) {
          this.completes[task.name] = false;
        } else {
          this.completes[task.name] = true;
        }
        return this.tryRun();
      }
    };

    TopLevelTask.prototype.tryRun = function() {
      var allFinished, allStopped, depend, key, _ref;
      allFinished = true;
      allStopped = true;
      _ref = this.depends;
      for (key in _ref) {
        depend = _ref[key];
        if (this.completes.hasOwnProperty(key)) {
          if (this.completes[key] === true) {
            allStopped = false;
          }
        } else {
          allFinished = false;
          break;
        }
      }
      if (allFinished) {
        this.reset();
        if (!allStopped) {
          return this.cb.call(this, null);
        } else {
          this.status = {
            stopped: true
          };
          return this.cb.call(this, null);
        }
      }
    };

    TopLevelTask.prototype.filterTasks = function(tasks, taskNames) {
      var name, result, _i, _len;
      result = {};
      for (_i = 0, _len = taskNames.length; _i < _len; _i++) {
        name = taskNames[_i];
        if (!tasks.hasOwnProperty(name)) {
          throw {
            error: 'unknown_task_name',
            name: name
          };
        }
        if (result.hasOwnProperty(name)) {
          continue;
        } else {
          this._filterRecurse(tasks[name], result);
        }
      }
      loglet.debug('TopLevelTask.filterTasks', taskNames, Object.keys(tasks), Object.keys(result));
      return result;
    };

    TopLevelTask.prototype._filterRecurse = function(task, result) {
      var depend, key, name, _ref, _results;
      name = task.name;
      result[name] = task;
      _ref = task.depends;
      _results = [];
      for (key in _ref) {
        depend = _ref[key];
        _results.push(this._filterRecurse(depend, result));
      }
      return _results;
    };

    TopLevelTask.prototype.findRoot = function(tasks) {
      var key, result, task;
      result = [];
      for (key in tasks) {
        task = tasks[key];
        loglet.debug('TopLevelTask.findRoot', task.name, task.dependsKeys());
        if (task.dependsKeys().length === 0) {
          result.push(task);
        }
      }
      return result;
    };

    TopLevelTask.prototype.findBottom = function(tasks) {
      var depend, isDepended, key, keys, noDepends, sourceTasks, task, _i, _len;
      noDepends = {};
      keys = [];
      sourceTasks = [];
      for (key in tasks) {
        task = tasks[key];
        noDepends[key] = task;
        keys.push(key);
        sourceTasks.push(task);
      }
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        key = keys[_i];
        depend = noDepends[key];
        isDepended = _.find(sourceTasks, function(task) {
          loglet.debug('TopLevelTask.findBottom.depend', key, task.name, task.dependsKeys(), task.dependsOn(depend));
          return task.dependsOn(depend);
        });
        if (isDepended) {
          delete noDepends[key];
        }
      }
      return noDepends;
    };

    TopLevelTask.prototype.start = function() {
      var task, _i, _len, _ref, _results;
      _ref = this.root;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        task = _ref[_i];
        _results.push(task.start());
      }
      return _results;
    };

    TopLevelTask.prototype.trace = function() {
      var key, task, _ref, _results;
      _ref = this.depends;
      _results = [];
      for (key in _ref) {
        task = _ref[key];
        _results.push(task.trace(1));
      }
      return _results;
    };

    return TopLevelTask;

  })(EventEmitter);

  Makelet = (function() {

    function Makelet() {
      this.tasks = {};
      this.roots = [];
    }

    Makelet.wildcard = patternFiles;

    Makelet.patsubst = patsubst;

    Makelet.prototype.wildcard = patternFiles;

    Makelet.prototype.patsubst = patsubst;

    Makelet.prototype.rootDir = patternRootDir;

    Makelet.prototype.regex = patternToRegex;

    Makelet.prototype.patternSplit = patternSplitAtRootDir;

    Makelet.prototype.getTask = function(name) {
      return _.find(this.tasks, function(task) {
        return task.name === name;
      });
    };

    Makelet.prototype.task = function(name, depends, work) {
      if (arguments.length === 2 && (depends instanceof Function)) {
        work = depends;
        depends = [];
      }
      if (this.tasks.hasOwnProperty(name)) {
        throw {
          error: 'duplicate_task_name',
          name: name
        };
      }
      this.tasks[name] = new TaskSpec(name, depends, work);
      return this;
    };

    Makelet.prototype.file = function(targetPath, dependPaths, work) {
      if (this.tasks.hasOwnProperty(targetPath)) {
        throw {
          error: 'duplicate_task_name',
          name: targetPath
        };
      }
      loglet.debug('Makelet.file', targetPath, dependPaths);
      this.tasks[targetPath] = new FileTaskSpec(targetPath, dependPaths, work);
      return this;
    };

    Makelet.prototype.pattern = function(files, targetPattern, sourcePattern, depends, work) {
      var fileMap, i, source, _i, _len;
      if (arguments.length === 4) {
        work = depends;
        depends = [];
      }
      fileMap = this.patsubst(files, sourcePattern, targetPattern);
      for (i = _i = 0, _len = files.length; _i < _len; i = ++_i) {
        source = files[i];
        loglet.debug('pattern', fileMap[i], source);
        this.file(fileMap[i], [source].concat(depends), work);
      }
      return this;
    };

    Makelet.prototype.fileMap = function(targetPaths, sourcePaths, work) {
      var i, targetPath, _i, _len;
      if (targetPaths.length !== sourcePaths.length) {
        throw {
          error: 'Makelet.fileMap:targets_and_sources_unequal',
          args: [targetPaths, sourcePaths, work]
        };
      }
      for (i = _i = 0, _len = targetPaths.length; _i < _len; i = ++_i) {
        targetPath = targetPaths[i];
        this.file(targetPath, [sourcePaths[i]], work);
      }
      return this;
    };

    Makelet.prototype.rule = function(targetPattern, sourcePattern, work) {
      var fileMap, source, target, _i, _len, _ref;
      fileMap = patternFileSubst(sourcePattern, targetPattern);
      for (_i = 0, _len = fileMap.length; _i < _len; _i++) {
        _ref = fileMap[_i], source = _ref[0], target = _ref[1];
        this.file(target, [source], work);
      }
      return this;
    };

    Makelet.prototype.makeTasks = function() {
      var depends, key, result, spec, task, tasks, _i, _len,
        _this = this;
      tasks = (function() {
        var _ref, _results;
        _ref = this.tasks;
        _results = [];
        for (key in _ref) {
          spec = _ref[key];
          _results.push(spec.make());
        }
        return _results;
      }).call(this);
      result = {};
      for (_i = 0, _len = tasks.length; _i < _len; _i++) {
        task = tasks[_i];
        depends = _.filter(tasks, function(depend) {
          return _this.tasks[task.name].dependsOn(depend.name);
        });
        task.addDepends(depends);
        result[task.name] = task;
      }
      return result;
    };

    Makelet.prototype.makeTasks2 = function(names) {
      var key, name, taskDict, val, _i, _len, _results;
      taskDict = {};
      for (_i = 0, _len = names.length; _i < _len; _i++) {
        name = names[_i];
        this.buildTask(name, taskDict);
      }
      _results = [];
      for (key in taskDict) {
        val = taskDict[key];
        _results.push(val);
      }
      return _results;
    };

    Makelet.prototype.buildTask = function(name, dict) {
      var depend, dependTasks, spec, _i, _len, _ref;
      if (dict == null) {
        dict = {};
      }
      if (!this.tasks.hasOwnProperty(name)) {
        throw {
          error: 'Makelet.unknown_task',
          name: name,
          tasks: this.tasks
        };
      }
      if (dict.hasOwnProperty(name)) {
        return dict[name];
      }
      spec = this.tasks[name];
      dict[name] = spec.make();
      dependTasks = [];
      _ref = spec.depends;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        depend = _ref[_i];
        if (this.tasks.hasOwnProperty(depend)) {
          dependTasks.push(this.buildTask(depend, dict));
        }
      }
      dict[name].addDepends(dependTasks);
      return dict[name];
    };

    Makelet.prototype.run = function() {
      var cb, targets, topLevel, _i;
      targets = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), cb = arguments[_i++];
      topLevel = new TopLevelTask(this, targets, cb);
      topLevel.start();
      return this;
    };

    return Makelet;

  })();

  Makelet.Task = Task;

  module.exports = Makelet;

}).call(this);
