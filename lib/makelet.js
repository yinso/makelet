// Generated by CoffeeScript 1.4.0
(function() {
  var EventEmitter, FileTask, FileTaskSpec, Makelet, Task, TaskSpec, TopLevelTask, async, fileNewerThan, fs, loglet, patternFileSubst, patternFiles, patternRootDir, patternToRegex, patternToReplace, utilities, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  loglet = require('loglet');

  fs = require('fs');

  utilities = require('utilities');

  _ = require('underscore');

  async = require('async');

  EventEmitter = require('events').EventEmitter;

  fileNewerThan = function(targetPath, dependPaths, cb) {
    var helper;
    helper = function(target, depends) {
      var res;
      res = _.find(depends, function(dep) {
        return target.mtime < dep.mtime;
      });
      if (res) {
        return true;
      } else {
        return false;
      }
    };
    return fs.stat(targetPath, function(err, target) {
      if (err) {
        loglet.debug('fileNewerThan:no_target', targetPath, err);
        return cb(null, true);
      } else {
        return async.map(dependPaths, fs.stat, function(err, depends) {
          if (err) {
            loglet.debug('fileNewerThan:no_depend_file', dependPaths, err);
            return cb(null, false);
          } else {
            return cb(null, helper(target, depends));
          }
        });
      }
    });
  };

  patternRootDir = function(pat) {
    var res, seg, segments, _i, _len;
    segments = pat.split('/');
    res = [];
    for (_i = 0, _len = segments.length; _i < _len; _i++) {
      seg = segments[_i];
      if (seg.indexOf('%') === -1) {
        res.push(seg);
        continue;
      } else {
        return res.join('/');
      }
    }
    return res.join('/');
  };

  patternToRegex = function(pat) {
    var regex;
    regex = pat.replace(/\\/g, '\\\\').replace(/\//g, '\\/').replace('.', '\\.').replace(/%/g, '([^\\\/\\\\]+?)');
    return new RegExp(regex);
  };

  patternToReplace = function(pat) {
    var i;
    i = 0;
    return pat.replace(/%/g, function() {
      i++;
      return "$" + i;
    });
  };

  patternFiles = function(pat) {
    var files, regex, rootDir;
    rootDir = patternRootDir(pat);
    regex = patternToRegex(pat);
    files = utilities.file.readdirR(rootDir);
    return _.filter(files, function(file) {
      return file.match(regex);
    });
  };

  patternFileSubst = function(sourcePat, targetPat) {
    var file, files, sourceRegex, _i, _len, _results;
    sourceRegex = patternToRegex(sourcePat);
    targetPat = patternToReplace(targetPat);
    files = patternFiles(sourcePat);
    _results = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      _results.push([file, file.replace(sourceRegex, targetPat)]);
    }
    return _results;
  };

  TaskSpec = (function() {

    function TaskSpec(name, depends, work) {
      this.name = name;
      this.depends = depends;
      this.work = work;
    }

    TaskSpec.prototype.make = function() {
      return new Task(this.name, this.work);
    };

    TaskSpec.prototype.dependsOn = function(name) {
      return this.depends.indexOf(name) !== -1;
    };

    return TaskSpec;

  })();

  Task = (function(_super) {

    __extends(Task, _super);

    function Task(name, work) {
      this.name = name;
      this.work = work;
      this._runCallback = __bind(this._runCallback, this);

      this.onDependDone = __bind(this.onDependDone, this);

      this.depends = {};
      this.completes = {};
      this.status = {};
    }

    Task.prototype.addDepends = function(depends) {
      var task, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = depends.length; _i < _len; _i++) {
        task = depends[_i];
        this.depends[task.name] = task;
        _results.push(task.once('done', this.onDependDone));
      }
      return _results;
    };

    Task.prototype.dependsOn = function(task) {
      return _.find(Object.keys(this.depends), function(name) {
        return task.name === name;
      });
    };

    Task.prototype.dependsKeys = function() {
      return Object.keys(this.depends);
    };

    Task.prototype.onDependDone = function(task, err) {
      if (err) {
        this.status = {
          error: err
        };
        this.reset();
        return this.emit('done', task, err);
      } else {
        if (err === false) {
          this.completes[task.name] = false;
        } else {
          this.completes[task.name] = true;
        }
        return this.tryRun();
      }
    };

    Task.prototype.reset = function() {
      var depend, key, _ref, _results;
      _ref = this.depends;
      _results = [];
      for (key in _ref) {
        depend = _ref[key];
        _results.push(depend.removeListener('done', this.onDependDone));
      }
      return _results;
    };

    Task.prototype.tryRun = function() {
      var allFinished, allStopped, depend, key, _ref;
      allFinished = true;
      allStopped = true;
      _ref = this.depends;
      for (key in _ref) {
        depend = _ref[key];
        if (this.completes.hasOwnProperty(key)) {
          if (this.completes[key] === true) {
            allStopped = false;
          }
        } else {
          allFinished = false;
          break;
        }
      }
      loglet.debug('Task.tryRun', this.name, this.completes, allFinished, allStopped);
      return this._startRun(allFinished, allStopped);
    };

    Task.prototype._startRun = function(allFinished, allStopped) {
      if (allFinished) {
        this.reset();
        if (!allStopped) {
          return this._run();
        } else {
          this.status = {
            stopped: true
          };
          return this.emit('done', this, false);
        }
      }
    };

    Task.prototype._run = function() {
      this.emit('start', this.name);
      return this.work.call(this, {}, this._runCallback);
    };

    Task.prototype._runCallback = function(err) {
      if (err) {
        this.status = {
          error: err
        };
        return this.emit('done', this, err);
      } else if (err === false) {
        this.status = {
          stopped: true
        };
        return this.emit('done', this, false);
      } else {
        this.status = {
          completed: true
        };
        return this.emit('done', this, null);
      }
    };

    Task.prototype.start = function() {
      return this._run();
    };

    return Task;

  })(EventEmitter);

  FileTask = (function(_super) {

    __extends(FileTask, _super);

    function FileTask(name, work, dependPaths) {
      this.dependPaths = dependPaths;
      FileTask.__super__.constructor.call(this, name, work);
    }

    FileTask.prototype.addDepends = function(depends) {
      var dependPaths, path, task, _i, _len, _ref;
      dependPaths = [];
      _ref = this.dependPaths;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        path = _ref[_i];
        task = _.find(depends, function(task) {
          return task.name === path;
        });
        if ((!task) || (task instanceof FileTask)) {
          dependPaths.push(path);
        }
      }
      this.dependPaths = dependPaths;
      return FileTask.__super__.addDepends.call(this, depends);
    };

    FileTask.prototype._startRun = function(allFinished, allStopped) {
      if (allFinished) {
        this.reset();
        return this._run();
      }
    };

    FileTask.prototype._run = function() {
      var _this = this;
      return fileNewerThan(this.name, this.dependPaths, function(err, res) {
        if (err) {
          return _this._runCallback(err);
        } else if (res) {
          return _this.work({
            source: _this.dependPaths[0],
            sources: _this.dependPaths,
            target: _this.name
          }, _this._runCallback);
        } else {
          return _this._runCallback(false);
        }
      });
    };

    return FileTask;

  })(Task);

  FileTaskSpec = (function(_super) {

    __extends(FileTaskSpec, _super);

    function FileTaskSpec() {
      return FileTaskSpec.__super__.constructor.apply(this, arguments);
    }

    FileTaskSpec.prototype.make = function() {
      return new FileTask(this.name, this.work, this.depends);
    };

    return FileTaskSpec;

  })(TaskSpec);

  TopLevelTask = (function(_super) {

    __extends(TopLevelTask, _super);

    function TopLevelTask(organizer, taskNames, cb) {
      var key, task, tasks, _ref;
      this.cb = cb;
      this.onDependDone = __bind(this.onDependDone, this);

      tasks = this.filterTasks(organizer.makeTasks(), taskNames);
      this.root = this.findRoot(tasks);
      this.depends = this.findBottom(tasks);
      loglet.debug('TopLevelTask.ctor', taskNames, this.root, this.depends);
      this.completes = {};
      _ref = this.depends;
      for (key in _ref) {
        task = _ref[key];
        task.once('done', this.onDependDone);
      }
    }

    TopLevelTask.prototype.reset = function() {
      var key, task, _ref, _results;
      _ref = this.bottom;
      _results = [];
      for (key in _ref) {
        task = _ref[key];
        _results.push(task.removeListener('done', this.onDependDone));
      }
      return _results;
    };

    TopLevelTask.prototype.onDependDone = function(task, err) {
      if (err) {
        this.reset();
        return this.cb.call(this, err);
      } else {
        if (err === false) {
          this.completes[task.name] = false;
        } else {
          this.completes[task.name] = true;
        }
        return this.tryRun();
      }
    };

    TopLevelTask.prototype.tryRun = function() {
      var allFinished, allStopped, depend, key, _ref;
      allFinished = true;
      allStopped = true;
      _ref = this.depends;
      for (key in _ref) {
        depend = _ref[key];
        if (this.completes.hasOwnProperty(key)) {
          if (this.completes[key] === true) {
            allStopped = false;
          }
        } else {
          allFinished = false;
          break;
        }
      }
      if (allFinished) {
        this.reset();
        if (!allStopped) {
          return this.cb.call(this, null);
        } else {
          this.status = {
            stopped: true
          };
          return this.cb.call(this, null);
        }
      }
    };

    TopLevelTask.prototype.filterTasks = function(tasks, taskNames) {
      var name, result, _i, _len;
      result = {};
      for (_i = 0, _len = taskNames.length; _i < _len; _i++) {
        name = taskNames[_i];
        if (!tasks.hasOwnProperty(name)) {
          throw {
            error: 'unknown_task_name',
            name: name
          };
        }
        if (result.hasOwnProperty(name)) {
          continue;
        } else {
          this._filterRecurse(tasks[name], result);
        }
      }
      loglet.debug('TopLevelTask.filterTasks', taskNames, Object.keys(tasks), Object.keys(result));
      return result;
    };

    TopLevelTask.prototype._filterRecurse = function(task, result) {
      var depend, key, name, _ref, _results;
      name = task.name;
      result[name] = task;
      _ref = task.depends;
      _results = [];
      for (key in _ref) {
        depend = _ref[key];
        _results.push(this._filterRecurse(depend, result));
      }
      return _results;
    };

    TopLevelTask.prototype.findRoot = function(tasks) {
      var key, result, task;
      result = [];
      for (key in tasks) {
        task = tasks[key];
        loglet.debug('TopLevelTask.findRoot', task.name, task.dependsKeys());
        if (task.dependsKeys().length === 0) {
          result.push(task);
        }
      }
      return result;
    };

    TopLevelTask.prototype.findBottom = function(tasks) {
      var depend, isDepended, key, keys, noDepends, sourceTasks, task, _i, _len;
      noDepends = {};
      keys = [];
      sourceTasks = [];
      for (key in tasks) {
        task = tasks[key];
        noDepends[key] = task;
        keys.push(key);
        sourceTasks.push(task);
      }
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        key = keys[_i];
        depend = noDepends[key];
        isDepended = _.find(sourceTasks, function(task) {
          loglet.debug('TopLevelTask.findBottom.depend', key, task.name, task.dependsKeys(), task.dependsOn(depend));
          return task.dependsOn(depend);
        });
        if (isDepended) {
          delete noDepends[key];
        }
      }
      return noDepends;
    };

    TopLevelTask.prototype.start = function() {
      var task, _i, _len, _ref, _results;
      _ref = this.root;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        task = _ref[_i];
        _results.push(task.start());
      }
      return _results;
    };

    return TopLevelTask;

  })(EventEmitter);

  Makelet = (function() {

    function Makelet() {
      this.tasks = {};
      this.roots = [];
    }

    Makelet.prototype.wildcard = patternFiles;

    Makelet.prototype.patsubst = function(files, sourcePat, targetPat) {
      var file, sourceRegex, _i, _len, _results;
      sourceRegex = patternToRegex(sourcePat);
      targetPat = patternToReplace(targetPat);
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        _results.push(file.replace(sourceRegex, targetPat));
      }
      return _results;
    };

    Makelet.prototype.getTask = function(name) {
      return _.find(this.tasks, function(task) {
        return task.name === name;
      });
    };

    Makelet.prototype.task = function(name, depends, work) {
      if (arguments.length === 2) {
        work = depends;
        depends = [];
      }
      if (this.tasks.hasOwnProperty(name)) {
        throw {
          error: 'duplicate_task_name',
          name: name
        };
      }
      this.tasks[name] = new TaskSpec(name, depends, work);
      this._add(name, depends, work, function(cb) {
        return work({}, cb);
      });
      return this;
    };

    Makelet.prototype._add = function(name, depends, work, cb) {};

    Makelet.prototype.file = function(targetPath, dependPaths, work) {
      if (this.tasks.hasOwnProperty(targetPath)) {
        throw {
          error: 'duplicate_task_name',
          name: targetPath
        };
      }
      loglet.debug('Makelet.file', targetPath, dependPaths);
      this.tasks[targetPath] = new FileTaskSpec(targetPath, dependPaths, work);
      this._add(targetPath, [], work, function(cb) {
        return fileNewerThan(targetPath, dependPaths, function(err, res) {
          if (err) {
            return cb(err);
          } else if (res) {
            return work({
              source: dependPaths[0],
              sources: dependPaths,
              target: targetPath
            }, cb);
          } else {
            return cb(null);
          }
        });
      });
      return this;
    };

    Makelet.prototype.pattern = function(files, targetPattern, sourcePattern, work) {
      var fileMap, i, source, _i, _len;
      fileMap = this.patsubst(files, sourcePattern, targetPattern);
      for (i = _i = 0, _len = files.length; _i < _len; i = ++_i) {
        source = files[i];
        loglet.debug('pattern', fileMap[i], source);
        this.file(fileMap[i], [source], work);
      }
      return this;
    };

    Makelet.prototype.rule = function(targetPattern, sourcePattern, work) {
      var fileMap, source, target, _i, _len, _ref;
      fileMap = patternFileSubst(sourcePattern, targetPattern);
      for (_i = 0, _len = fileMap.length; _i < _len; _i++) {
        _ref = fileMap[_i], source = _ref[0], target = _ref[1];
        this.file(target, [source], work);
      }
      return this;
    };

    Makelet.prototype.makeTasks = function() {
      var depends, key, result, spec, task, tasks, _i, _len,
        _this = this;
      tasks = (function() {
        var _ref, _results;
        _ref = this.tasks;
        _results = [];
        for (key in _ref) {
          spec = _ref[key];
          _results.push(spec.make());
        }
        return _results;
      }).call(this);
      result = {};
      for (_i = 0, _len = tasks.length; _i < _len; _i++) {
        task = tasks[_i];
        depends = _.filter(tasks, function(depend) {
          return _this.tasks[task.name].dependsOn(depend.name);
        });
        task.addDepends(depends);
        result[task.name] = task;
      }
      return result;
    };

    Makelet.prototype.run = function() {
      var cb, targets, topLevel, _i;
      targets = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), cb = arguments[_i++];
      topLevel = new TopLevelTask(this, targets, cb);
      loglet.debug('Makelet.run', topLevel);
      topLevel.start();
      return this;
    };

    return Makelet;

  })();

  Makelet.Task = Task;

  module.exports = Makelet;

}).call(this);
